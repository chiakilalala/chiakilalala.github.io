[{"content":"TweenMax GASP入門介紹 TweenMax是一個好用的動畫工具， 我覺得比jQuery更直覺，這系列筆記是根據 mike 成智遠老師 的TweenMax動態特效課程\n先備知識： css animation 概念\njavascript 基本概念 如：else if / Function / for\n1.物件id ＝\u0026gt;#box移動的物件\n2.多少秒數執行完成 =\u0026gt;動作的屬性\n3.x:\u0026ldquo;700px\u0026rdquo; 屬性 ＝\u0026gt; 水平位移 700px\nTweenMax.to(\u0026quot;#box\u0026quot;,1,{x:\u0026quot;500px\u0026quot;}) 注意點  似jQuery 的id命名方式  在網頁的世界裡面，(x,y) 起點是從左上角開始  第三個參數 是用物件包著{}  demo\n由左向右移動的車子（圖片為已完成行動時） Scale 比例縮放 效果出現對話框\n目的：如何使用 TweenMax 把東西縮放？\n第一步 針對物件對話 做變化\ntransftom:scale(0,0) 是縮到最小到看不到\n#dialogBox{ position: absolute; top: -20px; left: -30px; width: 259px; height: 196px; transform: scale(0, 0);//對話框縮到做小 background-image: url(\u0026quot;https://upload.cc/i1/2020/08/25/rBMF6j.png\u0026quot;) } 我們就針對這個來做變化\n 在很多程式的概念裡面，0是為小，1為最大。\n TweenMax.to(\u0026quot;#dialogBox\u0026quot;,1, { scaleX:1 ,//控制x方向大小 scaleY:1 ,//控制Y方向大小 }) 第二步 動畫物件位置 我們希望對話框可以從右下角跳出來，所以從 transform-Origin 變動位置，那記得一開始所說的物件最開始都是（0,0）左上角\n中間為（50,50） 右下方為（100,100）\nTweenMax.to(\u0026quot;#dialogBox\u0026quot;,1, { scaleX:1 ,//控制x方向大小 scaleY:1 ,//控制Y方向大小 transformOrigin:\u0026quot;100% 100%\u0026quot;,//動畫縮放中心點位置,希望從右下角開始 }) 第三步 速率變化 https://greensock.com/ease-visualizer\nease 是 TweenMax 針對動畫速率的屬性，我們可以根據上面網址知道各個效果是如何的？\n根據面板下面紅色框起來 複製下來放到 ease:\u0026ldquo;bounce.inOut\u0026rdquo; 測試你想要的動畫速率屬性。\nTweenMax.to(\u0026quot;#dialogBox\u0026quot;,1, { scaleX:1 ,//控制x方向大小 scaleY:1 ,//控制Y方向大小 transformOrigin:\u0026quot;100% 100%\u0026quot;,//動畫縮放中心點位置 印為希望從右下角開始 ease: \u0026quot;bounce.inOut\u0026quot;//控制動畫速率的部分 https://greensock.com/ease-visualizer }) demo\nCSS 屬性控制 用TweenMax 來操作css部分來產生動畫\n效果：頁面載入時，畫面由左到右 畫面寬度由 0% 到100%\n#box{ width: 0%; /*畫面設定為寬度0%*/ height: 100%; background-color: cadetblue; background-size:cover; background-image: url(\u0026quot;https://upload.cc/i1/2020/08/25/cz9MS1.jpg\u0026quot;); } TweenMax.to(\u0026quot;#box\u0026quot;, 3, { width:\u0026quot;100%\u0026quot;, ease: Bounce.easeOut//加上動畫速率使為生動 } ); demo\n","date":"2020-08-26T00:14:56+08:00","permalink":"https://chiakilalala.github.io/p/preview202008/","title":"TweenMax 入門筆記"},{"content":"前言： 最近在研究串接資料，剛好學習到了一個ES6的新用法，先來記錄說明一下。\n在此之前我們還要了解什麼是同步與非同步\n同步（synchronous）：發一個請求，就要等待服務器的響應結束，然後才能發第二請求！中間這段時間就是 londing ；刷新的是整個頁面。\n異步（asynchronous）：發一個請求後，無需等待服務器的響應，然後就可以發第二個請求！可以使用 Javascript 接受服務器的響應，然後使用 Javascript 來局部刷新。\n來個比較如下：\n   Async sync     one at a time more one at a time   執行了就馬上換下一個指令 第一個執行完才執行下一個    Async Actions  click, AJAX, SetInterval 解決方法， callback , promises, async await (這一次不討論，因為他是promises 的簡寫)  先說說callback，就是在function裡面再執行一個function 這是目前傳統用法來解決同步非同步的事情。\nvar btn ＝document.querySelector('#btn'); var doIt = function() { alert(\u0026quot;you triggered \u0026quot; + this.id); }; btn.addEventListener(\u0026quot;click\u0026quot;, doIt); 我們可以說 doIt 就是一個 callback 函式，\n回到今天想要講的 Promise :100:\n ES6新語法 Promise 物件代表一個即將完成、或失敗的非同步操作， 以及它所產生的值。 return resolve or reject （用到了兩個參數） ES6 Promise的實作中，會確保Promise物件一實體化後就會固定住狀態，要不就是\u0026quot;已實現\u0026quot;，要不就是\u0026quot;已拒絕\u0026quot;  附註：resolve 和 reject 是參數 大概會是長像下面一樣：\nconst promise = new Promise(function(resolve, reject) { // 成功時 resolve(value) // 失敗時 reject(reason) }); promise.then(function(value) { // on fulfillment(已實現時) }, function(reason) { // on rejection(已拒絕時) }) //http://eddychang.me/blog/javascript/88-promise-basic-usage.html 記住我們為什麼要把 Promise 用在 Ajax 上面：\n Ajax 是屬於一個透過 JavaScript 技術名稱，用於取得遠端資料；而 Promise 則是一個語法，專門用來處理非同步行為，並不是專門用來處理 Ajax 使用，所以兩者是不同的。\n 中文翻譯意思：\n 如果想等 A 結束之後再進行 B..?\n 用一個生活化例子就是，我們去百貨公司美食街吃東西，點完餐店員會給你一個小圓盤，等那圓盤動了，就可以去拿吃的。 結果成功就是 resolve ，失敗了就是rejected\nPromise:\n如果成功的話\u0026hellip; 如果失敗的話\u0026hellip; (resolve)\u0026lt;\u0026ndash;\u0026gt; (reject)\n先備知識： 函式建構式要先了解比較好喔！ JavaScript 建構式\n new Promise 代表的是建立一個 Promise 物件，function(resolve, reject){} 代表的是建構式裡面包含的執行函式( executor function )，執行函式包含，resolve、reject，這兩個函式作為參數，當事件成功時便會回傳 resolve 裡面的值，反之當事件失敗便會回傳 reject 裡面的值。\n 接下來說個例子， 我們先設定攻擊的大絕招，成功之後（resolve） 會發生什麼事\nlet Bigtrick = new Promise( (resolve,reject)=\u0026gt;{ // 可能是⼀個需要花時間的動作.. setTimeout(()=\u0026gt; resolve('火之呼吸'),3000); // setTimeout(function resolve(){ // resolve('火之呼吸'); // },3000) }); Bigtrick .then((skill)=\u0026gt;console.log(`使用招式：${skill}`)) //promise成功 .catch((err)=\u0026gt;console.log(`${err}無法使用`))//promise失敗 而 Bigtrick().then 的 then 代表了可以接收 Bigtrick() 這個 Promise 完成時，可以接受到回傳的值，如果回傳的值為錯誤時，則可以用 .catch 去做錯誤的值接收，.then 是可以一直串接下去的。這個行為叫做 Promise Chain\nsetTimeout（）用法  MDN 定義 setTimeout() 的作用 是在延遲了某段時間 (單位為毫秒) 之後，才去執行「一次」指定的程式碼\n 接下來製作一個小遊戲， 範例網址 點擊一個按鈕連擊 5次以上在三秒之內，成功執行後會產生招式名稱。\n我們先找到 按鈕和印出畫面的 dom，然後做出點擊時會發生的事件：數字chi變數=點擊次數出現在畫面\nlet chi =0; let i =0; let hitButton =document.getElementById('hitButton'); let result =document.getElementById('result'); hitButton.onclick=function(e){ e.preventDefault(); chi +=1; hitButton.innerHTML =`集氣 ${chi}次 `; } 那我們利用 new Promise()實作，要在三秒以內，點擊數超過5次才會出現 水之呼吸（利用 setTimeout 方法）\nlet bigSkill =new Promise((resolve,reject)=\u0026gt;{ setTimeout(()=\u0026gt;{ if(chi\u0026gt;=5){ resolve('水之呼吸！！'); }else{ reject('水之呼吸！！'); }; },3000); }); 成功達成條件後（點擊超過五次）resolve 就連上.then， 失敗 reject 就是被 catch 接到\nbigSkill .then( skill =\u0026gt; result.innerHTML =`發動招式：${skill}`) .catch( err =\u0026gt; result.innerHTML =`${err} 無法使用`) 畫面如下： 其實 promise 不是必要，在以前沒有 promise 的時候也是可以做到非同步的事。在 promise 之前，可以用 callback 的方式來處理，但如果連續的處理的事情多，callback 就容易一層包一層，程式碼會變得不容易閱讀，俗稱「callback hell」\n這樣是我真的對 callback function 怕怕的原因，函式包函式 ，腦袋都要昏了。\n而 promise 的出現，可以簡化 callback 的流程，用 then .. then .. 的方式來解決 callback hell 的狀況喔。\n資料來源：\n五倍速紅寶石 使用 Promise 處理非同步 Promise 對象\n ","date":"2020-03-01T10:40:16+08:00","permalink":"https://chiakilalala.github.io/p/javascrip006/","title":"用淺顯方式說明 Javascript 的 Promise"},{"content":"思考流程\n資料 (model) \u0026gt; 事件 (event) \u0026gt; 介面 (View)\ndemo 網址\n使用之前該理解的 Jacascript\nfor(迴圈) / function （函式）/ this / if\u0026hellip;else / classList.remove /classList.add\n來源：\nJavaScript 教學\n畫面效果如下： 點擊一個按鈕（電子發票） 另外一個按鈕的畫面 不會出現。\n  tab 點擊   面板\n   HTML 畫面  \u0026lt;div class=\u0026quot;btn-group checkout-btn\u0026quot; role=\u0026quot;group\u0026quot; id=\u0026quot;tabs\u0026quot;\u0026gt; \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;btn active\u0026quot; \u0026gt;電子發票\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;#\u0026quot; class=\u0026quot;btn\u0026quot; \u0026gt;郵寄發票\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; window.onload = function (){ // do something } 在網頁中的所有的元素(包括元素的所有關聯檔案：圖片、音視訊、flash等)都完全載入到瀏覽器之後才執行。\n指定dom\nlet tabLink = document.getElementById(\u0026quot;tabs\u0026quot;).querySelectorAll(\u0026quot;a\u0026quot;); let tabContents = document.getElementById(\u0026quot;tab-inner\u0026quot;).querySelectorAll('.form-content'); let tabLink ==\u0026gt; 宣告按鈕 a tabContents let tabContents ==\u0026gt; 宣告面板內容為 tabContents\n事件操作：進行事件監聽 click 在跑 for 迴圈（在找每個 a 連結中 ）執行 函式 panelDisplay\nfor(let i = 0; i \u0026lt; tabLink.length; i++){ tabLink[i].addEventListener('click',function(e){ e.preventDefault(); panelDisplay(this); }); }; 建立一個 function 名稱為 panelDisplay 賦予判斷條件為 class 有 active 時下面的面板會顯示，反之其他會隱藏內容\nfunction panelDisplay(activePanel){ // Do something... for(let i =0;i\u0026lt;tabLink.length;i++){ //設定條件tabLink ==activePanel //將tablink代入for循環中並利用 if ...else 進行條件 classList.add增加class=\u0026quot;active\u0026quot; ，就是每執行一次function的時候就進行全部tablinks增加class if(tabLink[i] == activePanel) // 假設目前的 tabLink 等於 activate, 改變他的class .active { tabLink[i].classList.add(\u0026quot;active\u0026quot;); // 顯示面板的display:block tabContents[i].style.display=\u0026quot;block\u0026quot;; }else{ // 假設目前的 ablink 不等於 activate, 刪除他的class .active tabLink[i].classList.remove(\u0026quot;active\u0026quot;); //隱藏 面板 tabContents[i].style.display=\u0026quot;none\u0026quot;; } } } }; ","date":"2020-02-07T00:00:00Z","permalink":"https://chiakilalala.github.io/p/javascrip/","title":"使用原生 Javascript 寫 tab 切換效果"},{"content":"前端基礎面試題(HTML+CSS部分+JS) 1.行內元素和塊級元素?img算什麼?行內元素怎麼轉化為塊級元素? 行內元素：和有他元素都在一行上，高度、行高及外邊距和內邊距都不可改變，文字圖片的寬度不可改變，只能容納文本或者其他行內元素；其中img是行元素 塊級元素：總是在新行上開始，高度、行高及外邊距和內邊距都可控制，可以容納內斂元素和其他元素； 行元素轉換為塊級元素方式：display：block；\n2.將多個元素設置為同一行?清除浮動有幾種方式? 將多個元素設置為同一行：float，inline-block 清除浮動的方式：\n 方法一：添加新的元素、應用clear：both； 方法二：父級div定義overflow: hidden； 方法三：利用:after和:before來在元素內部插入兩個元素塊，從面達到清除浮動的效果。  .clear{zoom:1;} .clear:after {content:””;clear:both; display:block; height:0; overflow:hidden; visibility:hidden; } 3.CSS hack \n  (1)圖片間隙 在div中插入圖片，圖片會將div下方撐大3px。hack1：將與寫在同一行。hack2：給添加display：block； dt li中的圖片間隙。hack：給添加display：block；\n  默認高度，IE6以下版本中，部分塊元素，擁有默認高度（低於18px） hack1：給元素添加：font-size：0； hack2：聲明： overflow：hidden；\n  表單行高不一致 hack1：給表單添加聲明：float：left；height： ；border： 0；\n  鼠標指針 hack：若統一某一元素鼠標指針為手型：cursor：pointer； 當li內的a轉化塊元素時，給a設置float，IE裡面會出現階梯狀 hack1：給a加display：inline-block； hack2：給li加float：left；```\n  ","date":"2019-07-17T14:26:00+08:00","permalink":"https://chiakilalala.github.io/p/f2e/","title":"前端基礎面試題(HTML+CSS部分+JS)"},{"content":"以行動裝置為第一優先 無論工程師或是設計師 千萬不能陷入專家陷阱，因為每個人的心智模式不一樣， 只須記住一件事情，以使用者意見為中心，來評估優化事項\n 主要點擊區範圍應擴大 手機menu可以滿版 商品照片一定要用清晰的畫素 無連結地方可以不用做滑鼠效果 首頁的商品建議加入價錢 得到的反饋是：不一定 如果網站是走高價位，顯示價錢無意義  社群連結不用太大按鈕 可透過ga分析 是否有些區塊 很少人點擊 根據數據統計，僅有0.2％的顧客會願意分享，但增加分享按鈕卻會降低您的頁面速度，在現在使用者普遍耐心不足的狀態下，或許省略分享按鈕是個更棒的選擇。\n排版簡單 清晰  視覺表現應統一 選單顏色太多 視覺雜亂 手機模式 點擊部分需要多點空間 顏色選單建議可控制在三個顏色以內 一旦將網站的顏色框定在簡單的配色方案之中，那麼就會留給內容更大的發揮空間。  讓客戶分心的地方不要太多  彈出窗口的必要性 找不到自己的位置 跟商品無關的blog/連結必要性  在介面上整合相似的功能，避免版面破碎化  設計師常因無心而設計出多欄位卻又相似的元素或功能，在頁面上就會顯得多餘甚至混淆影響使用者的操作。  讓社群來證明您的價值，而非老王賣瓜  利用社群的力量來幫助你說服客戶是相當聰明的策略，且可有效的提高轉換率。用戶看到別人的認可，或是討論你的產品服務時，會加強他們想要了解或使用的動機，所以試著把使用者的推薦文或是數據證明放在網站上吧!  讓可點擊和可選擇之元件的樣式有所差異，避免混淆 應用視覺元素之手法可以幫助使用者了解介面上的功能與結構，例如顏色、深度與對比度等。同時為了與你的使用者精準的溝通，需點擊的行為(如連結或按鈕)與需選擇的元件(如選單)設計上要有所區別，同時上方的文字必須描述清楚，才有利使用者辨別。\n別讓使用者填太多表單 人類天生不喜歡麻煩的事物，就如同大家不喜歡在網站上填寫太多的表單。每新增一項必填欄位，訪客放棄填寫的風險就越高。此外，並非所有人打字都相當快，而且在移動裝置上輸入簡直就是件苦差事。所以盡可能的只留必要欄位，不那麼重要的就不要讓使用者填了。但如果你真的有非常多必填欄位，可以試看看將第二重要的資訊在提交第一重要的資訊後，出現於單獨的頁面上，請使用者繼續填寫。\n避免讓使用者產生已經滾到 “網頁最底部” 的錯覺 沒錯，長型的滾動頁面的設計相當符合人性，但要小心訪客可能會因為設計不良而產生“已經滾到最底部”的錯覺，這會大大的降低轉換率。\n你可以透過視覺化的圖標或是小動畫，來告知或暗示使用者：網頁還沒置底，你們還可以繼續往下閱讀。另外，設計時也需小心各主題之間留白區域的尺寸，因為過大也會讓人產生底下無資訊的想法。\n以聚焦手法吸引使用者的目光，效果大於頁面上滿滿的連結 我們常會在頁面上留下許多”連結”，目的在於可以滿足使用者可能的所有需求(例如可了解更多)。不過，假如你的目的是讓使用者捲到頁面底部時，採取你期待他們做的動作，那你必須思考上述的做法是否恰當。因為在中間安插任何連結都可能導致使用者分心而忽視了你最希望他們做的事情，所以放置連結，其數量與位置都要取得平衡。怎麼取得平衡必須仰賴大家的經驗，不過至少我們知道減少多餘的連結，可增加使用者注意到你”最重要動作 (可能是按鈕)”的機會。\n直接操作比多階層下拉式選單 (contextless menus) 來的直覺 針對介面上的元素直接操作有時比整合的操作工具列還要來的方便直覺。如下圖，若各項目皆有一些可以讓使用者操作的功能，我們可以藉由點擊或鼠標覆蓋的方式來呈現一些功能或進行操作(如刪除或重新命名等)。另外還有一種常見的操作方式，就是點擊項目後，該項目會轉變為可編輯的狀態。\n然而，多階層下拉式選單(context of button)十分常見，但過多的階層可能會增加操作的步驟，所以下次設計時不妨考慮減少階層或直接操作的方法。\n當下就可以操作，何必再多開分頁 當頁面上有一些我們期望使用者做，並會帶來價值的功能時(例如留下聯絡方式)，最好可將實際的表單或欄位放置於本頁上。如下圖，欄位若能與頁面整合在同一層，其帶來的好處大於還要連結至別頁輸入的方式。\n那我們該怎麼做呢?首先，必須精簡流程的步驟，盡可能的讓使用者花最少的時間。接著，將精簡化的表單或欄位放置於該頁面上，除了可讓使用者直接操作外，使用者也可藉此預估完成所需的時間，這樣他們進行操作的意願會更高。\n","date":"2019-06-29T14:26:00+08:00","permalink":"https://chiakilalala.github.io/p/ui/ux%E4%BD%BF%E7%94%A8%E8%80%85%E7%B6%93%E9%A9%97/","title":"關於電子商務網站 ＵＩＵＸ 二三事"},{"content":"Ajax api 串接 API 基本概念  將 Client 與 Server 分開。 每個 Request 間都不應該保持 State (狀態)，意指 Request 不會攜帶 State、Data 使用 HTTP 方法  主要的 HTTP 動作  GET POST PUT DELETE  HTTP Status Code 對 Server 請求成功的 Request，Server 會用 Response 回覆你結果。 Response 主要會由三個數字組成，通常都是 1、2、3、4、5 開頭：\n 1xx：Server 正在處理你的請求 2xx：Okay 3xx：Server 能完成你想要他做的事情，但是他必須先做其他事 4xx：代表可能你可能發生錯誤 5xx：Server 發生錯誤，無法成功回覆你  ","date":"2019-05-21T14:26:00+08:00","permalink":"https://chiakilalala.github.io/p/api/","title":"Ajax api 串接"},{"content":"Hugo + github 個人blog 建立 之前是使用免費的網域 用wordpress 建立blog 想找個容易的模板 建立blog\n Mac 安装 Hugo 可以使用 HomeBrew 安裝 https://brew.sh/ 下載\nbrew install hugo 一個 Hugo 項目就是一個網站，創建命令如下\nhugo new site [project-name] 例如我的網站名稱是 blog,創建命令如下：\nhugo new site blog 創建完成後，在 blog 資料夾下會生成以下檔結構：\n ├── archetypes ├── assets ├── config ├── content ├── data ├── layouts ├── static └── themes 添加主題 (theme) 此處以 zozo 為例 為了快速搭建博客，可以使用主題。使用主題後，只需要向 content 資料夾添加 Markdown 檔即可。\ncd blog git clone https://github.com/olOwOlo/hugo-theme-even themes/zozo 你也可以選其他主題，進到該主題的 GitHub repo，將上面的網址改成 repo的網址、themes/zozo 改成 themes/你的主題名稱。\n將 /themes/zozo 中的 static 和 layouts 資料夾複製，取代根目錄中的 static 和 layouts 資料夾\n或是會有一些theme 供了頁面的 sample 給你，有個 exampleSite 資料夾，首先進入到 exampleSite 把 content 資料夾以及 config.toml 複製出來到根目錄下。\n建立新文章 hugo new posts/my-first-post.md 此指令會在 /content/posts 資料夾中建立 my-first-post.md。使用任意文字編輯器打開此 markdown 文件，將 draft 改成 false，文件內容任意。以後建立文章都是以此方式。\n編輯 config.toml baseURL = \u0026quot;https://chswei.github.io/\u0026quot; #改成你的GitHub帳號名稱 languageCode = \u0026quot;zh-tw\u0026quot; title = \u0026quot; Blog\u0026quot; #自由命名 本地測試 hugo server -D 執行完後，在瀏覽器中輸入網址 http://localhost:1313，就可以看到網站的雛形。\n部署到 GitHub ","date":"2019-05-14T00:00:00Z","permalink":"https://chiakilalala.github.io/p/theme-preview/","title":"Hugo + github 個人blog 建立"},{"content":"Javascript ES6 ES6 繼承  學會定義子類別。(extends 關鍵字) 學會使用 super 關鍵字呼叫父類別建構式。 學會利用已經定義好的子類別物件。  class 子類別名稱 extends 父類別名稱\n建立子類別物件: new 子類別名稱()\n定義子類別建構式: constructor{ super(); //呼叫父類別建構式 }\n子類別物件 同樣擁有 父類別 中定義的屬性和方法\n在 子類別 中定義方法，會覆蓋 / 取代 父類別 中的同名方法 car.run(); 子類別物件可以呼叫父類別的方法\n定義靜態方法: 在 類別 中定義\n static 方法名稱(參數) { 程式碼 }  呼叫靜態方法: 使用 類別名稱 呼叫\n 類別名稱.方法名稱(參數)  取得原型物件: Object.getPrototypeOf(物件)\nnull是Object的原型物件\nclass Car{ constructor(color){this.color=color;} run(){} } // let car =new Car(\u0026ldquo;green\u0026rdquo;);\nlet carProto=Object.getPrototype(car); console.log(carProto);//Car 原型物件 let objProto=Object.getPrototype(carProto); //Object 原型物件 console.log(objProto); let lastOne=Object.getPrototype(objProto); console.log(lastOne);//原形練的終點 null\n練習 // 定義子類別 class 子類別 extends 父類別{ constructor(參數){ super(參數); // 呼叫父類別的建構式 } sleep(){ }// 子類別的其他方法定義 } // 這是 Animal 類別，請不要更動 class Animal{ constructor(name){ this.name=name; } sleep(){ //定義sleep 方法 console.log(this.name+\u0026quot;睡覺\u0026quot;); } } /* 練習一： 定義一個 Cat 子類別，繼承 Animal 類別。 並滿足下方程式碼的操作需求 */ class Cat extends Animal{ constructor(name); super(name); } speak(){ console.log(\u0026quot;喵!喵!\u0026quot;); } // 以下 Cat 子類別的操作 let cat=new Cat(\u0026quot;小花\u0026quot;); cat.sleep(); // 印出：\u0026quot;小花睡覺\u0026quot; cat.speak(); // 印出：\u0026quot;喵!喵!\u0026quot; /* 練習二： 定義一個 Dog 子類別，繼承 Animal 類別。 並滿足下方程式碼的操作需求 */ class Dog extends Animal{ constructor(name); super(name);// 請在這裡完成 Dog 子類別的定義 } sleep(hours){ console.log(this.name+\u0026quot;睡了\u0026quot;+hours+\u0026quot;小時\u0026quot;) } // 以下 Dog 子類別的操作 let dog=new Dog(\u0026quot;小黑\u0026quot;); dog.sleep(3); // 印出：\u0026quot;小黑睡了3小時\u0026quot; // 定義靜態方法 class 類別名稱{ static 靜態方法名稱(參數列表){ 靜態方法中的程式碼 } } // 使用靜態方法 類別名稱.靜態方法名稱(參數資料);\n// Geometry 類別提供平面座標系統的數學運算功能 class Geometry{ // 在這裡定義靜態方法 static distance(x1,y1,x2,y2){ let length=Math.sqrt(Math.pow(x2-x1, 2)+Math.pow(y2-y1, 2)); console.log(length); } } // 計算座標 (1,1) 和 (4,4) 的直線距離：大約 4.24 Geometry.distance(1,1,4,4); // 計算線段 (1,2) ~ (3,4) 的斜率：1 Geometry.slope(1,2,3,4); /* 以上簡易的幾何計算，使用 JS 內建的 Math 物件，以及公式： 直線距離：開根號(平方(x2-x1)+平方(y2-y1)) 斜率：(y2-y1)/(x2-x1) 由於這是程式課程，非數學課程 若只能寫出靜態方法的骨架，印出訊息，也算過關 */ ","date":"2019-05-11T00:00:00Z","permalink":"https://chiakilalala.github.io/p/javascrip/","title":"Javascript ES6 繼承"},{"content":"#Javascript ES6 常數 筆記\nconst 常數名稱 let 宣告變數\n// var 變數的 scope 以函式為界線，迴圈內外屬於同一個 scope for(var i=0;i\u0026lt;3;i++){ console.log(\u0026quot;i:\u0026quot;+i); } console.log(\u0026quot;outside i:\u0026quot;+i); // 請將上方的變數 i 換用 let 宣告，比較輸出的差異。\n// var 變數的 scope 以函式為界線，迴圈內外屬於同一個 scope\nfor(let i=0;i\u0026lt;3;i++){ console.log(\u0026quot;i:\u0026quot;+i); } console.log(\u0026quot;outside i:\u0026quot;+i); let const var 差別\n var 變數的 scope 以函式為界線，迴圈內外屬於同一個 scope scope 可用範圍 let 可用範圍以程式區塊 ( 大括號 ) 為分界線 let 以變數scope for(let i=0; i\u0026lt;5;i++){ console.log(i); } const 宣告常數 常數資料不能變動  使用 =\u0026gt; 建立函式 ① (參數列表)=\u0026gt;(回傳值) ② (參數列表)=\u0026gt;{函式內部程式}\n//傳統寫法 setTimeout(function(){ console.log(\u0026quot;過了一秒\u0026quot;); },1000); ES6 (參數列表)=\u0026gt;(回傳值) setTimeout(()=\u0026gt;{ console.log(\u0026quot;過了一秒\u0026quot;); },1000); ① (參數列表)=\u0026gt;(回傳值) 的使用方式 傳統寫法 let add=function( n1 , n2 ){ return n1+n2; } ES6 寫法 let add=( n1 , n2 )=\u0026gt;( n1+n2 ) ② (參數列表)=\u0026gt;{函式內部程式} 的使用方式 傳統寫法 let add=function( n1 , n2 ){ return n1+n2; } ES6 寫法 let add=( n1 , n2 )=\u0026gt;{ return n1+n2; } `// 展示訊息：請改成箭頭函式 let showMessage=(message)=\u0026gt;{ console.log(message); }; // 計算 1+2+...+max：請改成箭頭函式 let sum=(max)=\u0026gt;{ let n=1; let result=0; while(n\u0026lt;=max){ result+=n; n++; } return result; }; // 兩秒後跳出警告視窗：請改成箭頭函式 setTimeout(()=\u0026gt;{ alert(\u0026quot;過了兩秒\u0026quot;); }, 2000); // 以下呼叫上方的函式，不用做任何更動 showMessage(\u0026quot;Hello\u0026quot;); sum(50); // 得到回傳值 1275`` // 傳統的寫法一 function add(n1, n2){函式主體} // 傳統的寫法二 let add=function(n1, n2){函式主體} // 傳統的匿名函式 function(n1, n2){函式主體}\n// 箭頭函式一 let add=(n1, n2)=\u0026gt;(回傳值) // 箭頭函式二 let add=(n1, n2)=\u0026gt;{函式主體} // 箭頭函式撰寫匿名函式 (n1, n2)=\u0026gt;(回傳值) (n1, n2)=\u0026gt;{函式主體}\n函式參數預設值 (name 1=預設值1 name2 =預設值2)\nlet show=(message=\u0026ldquo;預設值\u0026rdquo;)＝\u0026gt;{alert(message);}; show(\u0026ldquo;hello\u0026rdquo;); show();\n-範例1 function multiply(n1,n2=1){ return n1*n2; } multiply(3,4); multiply(5);\n-範例2 function multiply(n1,n2=1)=\u0026gt;(n1*n2); multiply(3,4); multiply(5);\n後方的參數可以使用前面參數的名稱 function combine(first=\u0026ldquo;Jedi\u0026rdquo;,last=\u0026ldquo;Wang\u0026rdquo;,name=first+\u0026quot;\u0026quot;+last){ alert(name); } combine(\u0026ldquo;Helen\u0026rdquo;,\u0026ldquo;Li\u0026rdquo;); combine(\u0026ldquo;Helen\u0026rdquo;); combine();//\n/ 傳統函式寫法 function t1(n1=5){} let t2=function(n1,n2=4){} // 箭頭函式寫法 let t3=(x=4,y=5)=\u0026gt;(); let t4=(message=\u0026ldquo;若沒有資料，就用這個資料\u0026rdquo;)=\u0026gt;{}\n/* 以下是等差級數的加法，做 1+2+..+max 的總和 若呼叫時沒給定參數資料，則輸出：不做事 請修改函式內部的程式碼，以滿足呼叫時的預期結果 */ function sum(max=0){ if(max==0){ console.log(\u0026ldquo;不做事\u0026rdquo;); }else{ let result=0; let n=1; while(n\u0026lt;=max){ result+=n; n++; } console.log(\u0026ldquo;1+2+..+\u0026quot;+max+\u0026quot;=\u0026quot;+result); } } // 修改後的函式，必須滿足以下的輸出結果 sum(); // 輸出：不做事 sum(100); // 輸出：1+2+\u0026hellip;+100=5050\nfunction add(n1=1, n2=0){ console.log(n1+n2); } // 修改後的函式，必須滿足以下的輸出結果 add(3, 4); // 輸出：7 add(5); // 輸出：5 add(); // 輸出：1\n類別：設計圖\n物件：根據設計圖製造出來的實體\n一個「類別」設計可以用來產生無數個「物件實體」\n類別: class constructor\n產生物件實體關鍵字：new\n定義類別：class 類別名稱{ } ex: class Car{ } 建立物件：new 類別名稱() ex: let car1 = new Car\nConstructor 建構式\n 建構物件用的函式 建立新物件時會被呼叫的函式 JavaScript 會內建一個空白建構式(即便你沒寫建構式)  class Car { constructor(){ console.log(\u0026quot;THIS IS CALLED\u0026quot;); } } let car1 =new Car(); 屬性：用來描述物件的個別差異\nconstructor(參數列表) { this.屬性名稱 = 初始資料 } let car1 =new Car(); consrtructor(參數列表){ this.屬性名稱=初始資料; } this代表 正要產生的新物件 obj 屬性名稱 ex color this.color let car1= new Car(); 呼叫建構式 資料會拿到color 屬性 constructor(color){ this.color=color //建立新屬性color 資料偷過參數 彈性的 在建立物件時提供的 } //利用已經定義好的類別產生新物件 let car1 = new Car(\u0026quot;blue\u0026quot;); let car2 = new Car(\u0026quot;green\u0026quot;); this代表 正要產生的新物件 obj\n物件.屬性名稱 物件.屬性名稱 ＝新資料\n方法:與物件綁定的function method 方法\n 用來描述物件可以做的事 與物件綁定的函式  呼叫物件方法： 物件.方法名稱(參數資料)\n在物件方法中使用 this 代表綁定物件\nrun(){ console.log(\u0026ldquo;Car \u0026quot; + this.color+\u0026ldquo;Running\u0026rdquo;); } let car1 = new Car(\u0026ldquo;blue\u0026rdquo;); car1.run(); // \u0026ldquo;Car blue Running\u0026rdquo;\nclass Animal{ constructor(name){ this.name=name; } // 撰寫建構式，以滿足下方的輸出要求 sleep(){ console.log(this.name+\u0026ldquo;is Sleeping\u0026rdquo;); } // 撰寫方法，以滿足下方的輸出要求 \u0026hellip; }\nlet a=new Animal(\u0026ldquo;Mini\u0026rdquo;); console.log(a.name); // 印出 \u0026ldquo;Mini\u0026rdquo; a.sleep(); // 印出 \u0026ldquo;Mini is Sleeping\u0026rdquo;\n// 建立物件 new 類別名稱(參數資料) // 存取屬性 物件.屬性名稱 // 呼叫方法 物件.方法名稱(參數資料) class SimpleAnimal{ constructor(name){ this.name=name; } sleep(){ console.log(this.name+\u0026quot;is Sleeping\u0026quot;); } } let a = new SimpleAnimal(\u0026quot;Spot\u0026quot;); console.log(a.name); a.sleep; // 練習二：進階練習 class Animal{ constructor(name,kg){ this.name=name; this.kg=kg; }// 撰寫建構式，以滿足下方的輸出要求 eat(moreKG){ this.kg+=moreKG; console.log(this.name+\u0026quot;吃飯, 增加\u0026quot;+moreKG+\u0026quot;公斤，現在\u0026quot;+this.kg+\u0026quot;公斤\u0026quot;); } defecate(lessKG){ this.kg-=lessKG; console.log(this.name+\u0026quot;大號,減少\u0026quot;+lessKG+\u0026quot;公斤，現在 \u0026quot;+this.kg+\u0026quot;公斤\u0026quot;); }// 撰寫方法，以滿足下方的輸出要求 }; let a=new Animal(\u0026quot;Mini\u0026quot;, 2); console.log(a.name+\u0026quot;: \u0026quot;+a.kg+\u0026quot; 公斤\u0026quot;); // 印出 \u0026quot;Mini: 2 公斤\u0026quot; a.eat(0.1); // 印出 \u0026quot;Mini 吃飯，增加 0.1 公斤，現在 2.1 公斤\u0026quot; a.defecate(0.08); // 印出 \u0026quot;Mini 大號，減少 0.08 公斤，現在 2.02 公斤\u0026quot; ","date":"2019-05-10T06:53:46+08:00","permalink":"https://chiakilalala.github.io/p/javascript-%E5%B8%B8%E6%95%B8-es6-%E7%AD%86%E8%A8%98/","title":"Javascript  常數 ES6 筆記"},{"content":"JS 30day Day2 JS and CSS Clock 筆記 demo\n目的 學會 js Time 和 用js 操作css 還有基本的ES6語法\n步驟  利用css 製作 分針 時針 秒針 取時間的函數 製作js 函數 setＤate 取出現在的時間  const now = new Date(); // const seconds = now.getSeconds(); const mins = now.getMinutes(); const hour = now.getHours(); 3.利用時間取得對應角度\nconst secondsDegrees = ((seconds / 60) * 360) + 90; 零點角度 rotate。秒針轉一圈 60s，每一秒對應角度為 (\u0026hellip;s / 60s) * 360°。\n4.用得到角度 給值html在style的transform屬性上\nconst seconds = now.getSeconds(); const secondsDegrees = ((seconds / 60) * 360) + 90; secondHand.style.transform = `rotate(${secondsDegrees}deg)`; 5.放上js 計時器\n setInterval(setDate, 1000); //每一1000毫秒 觸發函式 挑戰 影片有提出 若指針在354度切到0度時， 會使指針往前彈回去，這是因為有使用transtion，在角度做切換時會加上的動畫效果， 354→0度會認為是往前，而非轉一圈回到起點，所以動畫先往前轉到0。 解法有：\n 修改transition 秒數 角度增加  css\u0026amp;js 補充 es6 基本 const 常數 不允許之後做改變 不允許重複宣告 不允許宣告前使用\n let 變數\n let 禁止在同一活動範圍中再次宣告相同名稱的變數。var 會無視第二次宣告，只管指派變數值。但 let 視為重複宣告的語法錯誤。 let 禁止在宣告變數之前就使用它。 在全域範圍以 let 宣告的變數，不會成為全域個體(global object)的屬性。但以 var 宣告的變數同時也會是全域個體的屬性。因此 let 變數是真正的區域變數，你用 module 或其他方式載入的程式碼看不到那些 let 變數。註: 在瀏覽器中運行的 JavaScript 之全域個體一律是 window 。    補充link\n  Template strings\nsecondHand.style.transform = `rotate(${secondsDegrees}deg)`;` 反括號裡面可以帶變數 補充link 補充link02\ncss transform 一個很複雜要常搞混的地方 transform-oragin 時鐘的軸點和軸心的初始位置 trsition :指針跳動時的轉場動畫 js 語法 ","date":"2019-05-07T07:43:32+08:00","permalink":"https://chiakilalala.github.io/p/js-30day-day2-js-and-css-clock-%E7%AD%86%E8%A8%98/","title":"JS 30day Day2  JS and CSS Clock 筆記"},{"content":"UI/UX 設計指南分享 在這邊整理一些網路上整理下來的UI設計的一些小知識，在設計介面與流程時可以參考。\n關於UI Element的使用建議參考看看即可，因為UI的世界瞬息萬變，大家使用的方法也不盡相同，不過我覺得比較重要，也希望大家可以放在心上的概念是Microcopy，我認為這是不管在什麼地方都受用的觀念。\n文件大綱：\n Dropdowns(下拉式選單) Switch/Toggle(開關按鈕) Placeholder Microcopy(小提示) - 一段簡短的文字，但能幫助使用者操作系統時更流暢 Label Placement - 表單中的Label到底要放在Field上面還是左邊啊？ Form(表單)   Dropdowns(下拉式選單)  下拉選單使用時機是選項介於 7 ~ 15 項 少於 7 項的話，建議使用Radio button，可以直接看到所有的選項 超過 15 個選項的話，建議搭配文字搜尋欄位，如下圖   但是當選項中有預設選項，像是字體大小選擇一般“適中”，使用Dropdowns即可  列出所有選項會造成使用者分心 並不鼓勵使用者去更改預設選項.     參考資料：\n 7 Rules of Using Radio Buttons vs Drop-Down Menus   In case you have less than 7 options you should consider using radio buttons. Your users will be able immediately scan how many options they have and what each of those options are, without clicking (or typing) anything to reveal this information.\n  Use Radio Buttons Rather Than Drop-downs If possible, use radio buttons rather than drop-down menus. Radio buttons have lower cognitive load because they make all options visible so that users can easily compare them.\n  Switch/Toggle(開關按鈕) 單個Switch與CheckBox看起來功用一模一樣，但有一個地方不同，先看看下圖。\n當Switch Button按下時同時也會馬上儲存現在的設定，但如果需要按下儲存確認鍵才會更改設定，就要使用Checkbox了。\n參考資料：\n when-to-use-a-switch-or-checkbox 選取控件的使用時機與限制   Placeholder 很多人常常拿Placeholder主要是在輸入欄位中提示「輸入範例」與「輸入限制」，有些人不太喜歡這種方式，在這邊提出另一種對Placeholder的看法\n Rather than risk having users stumble while filling out forms or waste valuable time figuring out how they work, the best solution is to have clear, visible labels that are placed outside empty form fields.\n Placeholder as an example ↓\nPlaceholder as help text ↓\nPlaceholder as secondary label(s) ↓\n補充的文字直接放在placholder內的話，使用者在開始打字的時候如果忘記補充文字的內容，必須刪掉輸入內容後才能看到，考驗使用者的短期記憶力，所以像上面提到的，把說明文字放在欄位旁邊是個不錯的做法。\n不過placeholder並沒有絕對的限制，如果整體使用情境不錯，還是可以打破上述規則，像是登入頁面的帳號密碼，因為大眾早已習慣兩個輸入框，上方是帳號，下方是密碼，所以就算直接把「帳號」、「密碼」寫在placeholder裡應該也不影響使用。\nNielsen Norman Group曾做過的一項眼球追蹤研究就說明，空的輸入框比有提示文字的輸入框更能引起用戶的關注，而且與空的輸入框相比，用戶更容易忽略有提示文字的輸入框，因為用戶乍看會覺得像已經填寫過的樣子。換句話說，被認為是有用的表單提示文字其實弊大於利，尤其是對習慣大致瀏覽的用戶，但我在瀏覽其他網站的時候，只要placeholder的顏色夠淡，感覺不太會有不順暢的感覺。\n現在的Material Design的Adaptive Placeholders可以讓placeholder在輸入時轉換成標題，不過那沒有達到補充說明欄位的效果，所以在此不討論。\nAdaptive Placeholders ↓\n參考資料：\n 新規則！5個表單經典原則 Alternatives to Placeholder Text - Improve form usability by addressing the perils of placeholders 4 reasons to avoid using placeholder text in forms 表單不單純—深究button\u0026amp;input\u0026amp;form 你的表單害你沒訂單？9 個常見的表單設計問題 新規則！5個表單經典原則   Microcopy(小提示) Microcopy是幾句簡短的文字，幫助使用者了解該做什麼或是舒緩對系統感到的困惑，達到的功效如下。以下依照功用分類進行介紹。\n1. 消弭使用者的擔憂 對使用者進行承諾，讓使用者安心。\n承諾使用者不會濫用他的資料去twitter自動發文，或是對他的朋友發送垃圾信以及和自動關注帳戶 ↓\n告知使用者取得他們資料的原因 ↓\n2. 提供訊息補充說明 提到這個就必須説說Information Icon了，因為有些資料輸入欄位很難從欄位名稱看出該輸入的什麼樣的資訊，所以通常會在輸入欄位的Label旁加上information icon，icon上會有是 ? 或 i 的樣式。按下icon的時候會跳出tooltip，詳細解說這欄位的用意或該輸入什麼。\nInformation Icon 的用處\n Contrary to help hints, tooltips at first hide the information and then display it on demand. They are usually fuelled by an icon with a question mark. Help information is given by keeping on help icon or selecting it. Once the mouse goes far from the icon, the tooltips vanishes. These can effectively help in reducing clutter especially when the help text is lengthy.\n Facebook 的 info icon ↓\nWalmart 的 info icon ↓\nLine Creator 的 info icon ↓\n如果這個資訊相當重要，那就可以直接顯示文字資訊，而不要用info icon\n If the information is extremely salient, consider displaying it at all times rather than as a tooltip.\n 參考資料：\n 7 guidelines for writing accessible microcopy  3. 有用的錯誤訊息 當事情出錯時，知道發生什麼狀況有益解決它。如果你對錯誤的說明很模糊，想解決這些錯誤的使用者會很痛苦，如錯誤訊息的範例下圖。\n Error message should be clear  錯誤訊息不要只寫「發生錯誤，請再試一次」這樣含糊的字句，你要想像你正在跟使用者說話，使用更好懂更具體的描述吧！\nError message should be helpful  除了給予錯誤原因，最好給予解決方法，在下圖中，當登入失敗時，系統不只告知錯誤狀況，還提供了2個解決方法，後者的方法還提供了連結幫助使用者解決問題。\nError message should be specific to the situation  大部分網站對所有驗證狀態只會給給予一種錯誤訊息，然而MailChimp官方網站中填寫email欄位時會有3種不同的錯誤訊息，這種客製化的錯誤訊息我覺得最完美，但是也非常費工，我覺得在使用者最容易犯錯的欄位進行這種優化即可。\n以上提到撰寫錯誤訊息的建議是從How to Write a Perfect Error Message這篇文章取出最重要的三點，其他說明可以點進去看看。\n參考資料：\n [Youtube] What is Microcopy Microcopy: 簡短的小提醒造成巨大的影響 How to Write a Perfect Error Message 4 Form Design UX Tips You Should Know - 有提到Microcopy，在章節 Example: Expressive Tooltips The Best Place for Error Messages on Forms - 錯誤訊息放在欄位右方或下方比較好   What is Microcopy: The small bits of text/copy that help instruct and alleviate(減緩) the concerns of your users.\n  By definition, the microcopy of a website consists of small chunks of text used in different elements – labels, buttons, error messages, tooltips, etc.\n  UI 頁面狀態：空白狀態（empty state） 當你第一次使用系統時，有很多頁面都沒使用過，例如使用相片編輯軟體，但是沒建立任何檔案，此時畫面會是空白的一片，這就是所謂的空白狀態（empty state），請看 設計師最常忽略的 UI 頁面狀態：空白狀態（empty state），將會告訴你如何將空白狀態（empty state）處理的更完善。\n Label Placement Label與Field的關係也是一門學問，擺放的位置主要分成以下三種\nLabel 在 Field 正上方 普遍的狀況下最實用的一種排版方式，它方便觀看，如果把Label放在Field左側，眼睛注視表單時就必須在Label與Field之間左右來回移動，增加負荷，另一點是表單如果支援多國語系，label長度會不同，尤其法文的長度大致是英文的兩倍長。\n優點\n Label與Field靠得很近，方便觀看，降低負荷 Label在多國語系下長度不同，也不會影響排版 在行動裝置上更方便觀看，如果Label跟Field分成左右兩邊的話，畫面會很擠  缺點\n 表單會變的很長，而且無法一次觀看到所有的Label。  Label 在 Field 左側 優點\n 整張表單的高度可以縮減，Form不會太長 可以一次觀看到所有的Label，快速跳到你想填的欄位  缺點\n 在填表時，眼睛必須左右來回觀看Label與Field，增加負荷 Label在多國語系下長度不同，容易影響到排版 在行動裝置上排版會很擠，不方便觀看  Label 在 Field 左側 - 靠右對齊的 Label 如果要把Label放在Field左側，至少用向右對齊的版本\nLabel 在 Field 左側 - 靠左對齊的 Label 效果最差，眼睛要左看右看，負荷很大，應該算是最要不得的排版，雖然有人說在掃描整個Label時，因為靠左對齊的關係，比較好看，但整體起來還是不好用的。 結論 在一般使用者填表的時候，我覺得盡量都用「Label在Field正上方」，但是在管理或是設定頁面時，有時候欄位很多（像是管理介面），想設定的欄位只有特定一兩個，並不需要從頭到尾每個欄位都填過，或許用「Label在Field左側 - 靠右對齊的Label」也是一種很好的選擇。若想使用「Label 在 Field 左側 - 靠左對齊的 Label」的方法，用有框線的表格更能幫助閱讀。\n參考資料\n Label Placement in Forms Label placement in forms: what’s best? Top, Right or Left Aligned Form Labels Web Application Form Design   Form 按鈕命名 避免使用\u0026quot;送出\u0026quot;之類的通用詞語來按鈕表示行為，因為它們給人的印象太通用了。相反地，請說明按鈕在點擊時執行的行為，例如\u0026quot;創立我的帳戶\u0026quot;或\u0026quot;訂閱每週優惠\u0026quot;。\n 按鈕位置 按鈕位置雖然查到了一些研究與解釋，但似乎沒有個定案，以下大家參考看看就好。\n在Dialog中，按鈕會被擺在右下角，因為放在右邊的東西有下一步的感覺，也符合閱讀的順序，而如果有Cancel與OK的多個按鈕，主按鈕應該放在最右側，也就是OK按鈕。\n↓ 符合閱讀順序 ↓ User會看完所有按鈕再決定按哪個，所以主按鈕在左側會讓眼神多飄移一次 但是在整頁的大型的表單中(非Dialog)，lukew的文章中建議把按鈕放左側是較好的方案，我覺得按鈕對齊按鈕input欄位應該是關鍵，因為user可能會回頭查看表單input的資料，再往下找按鈕的時候，也能較快速定位到按鈕。所以放左邊跟中間的按鈕較多，但在表單中把按鈕放右邊比較少。\n↓ Airbnb ↓ Github 參考資料\n Submit Buttons on the Left or the Right? Primary \u0026amp; Secondary Actions in Web Forms   別太輕易送出表單 在登入頁面的帳密輸入框與搜尋引擎的搜尋Bar中常會實作按下Enter鍵就送出表單的功能，其他地方可以用這招嗎？我個人的看法是如果這方法不會改變資料的話就無所謂，但如果是新建或是刪除資料的表單最好還是不用比較好，雖然FB的發文就是按下Enter就送出，所以這方便大家就參考看看吧！\n 表單驗證時機 驗證分成兩類，而inline validation又再分兩類\n After Submit Validation Inline Validation  Validate during the data entry Validate after the data entry    After Submit Validation 有一派說法是贊成After Submit Validation，他們認為在user輸入資料時一直驗證會打斷user思考，user在填飽的時候會進入「填表模式」，當送出資料後，會轉換成「修改模式」去修正剛剛沒打對的地方，所以他們認為不應該打斷填表模式。\nInline Validation： 在使用者輸入某個欄位時，就進行驗證，不等到最後送出後才驗證，首先先來看兩種inline validation的驗證方式。\n  Validate during the data entry： 輸入資料的同時就會一邊即時驗證。\n  Validate after the data entry： 在輸入完資料後，離開這個輸入欄位或是當已經輸入到此欄位長度的最大值，才開始驗證。\n   在「Usability Testing of Inline Form Validation」文中提到如何做出最好的inline validation，我把結論整理在下方，\n常見錯誤1: 倉促的驗證 如果直接使用「Validate during the data entry」，使用者在點擊欄位或是才剛輸入第一個字元時就會看到錯誤訊息，user會覺得自己明明還沒打完，為什麼要被這樣糾正，體驗並不好。\n解法：在第一次輸入的時候，記得使用「Validate after the data entry」，在使用者確實輸入完資料再驗證，體驗會較佳，如此便能解決常見錯誤1。\n常見錯誤2: 過時的驗證 在「Validate after the data entry」後發現資料驗證錯誤，顯示錯誤訊息，而user回頭進行修改的時候，修改完後離開欄位(onblur event)，系統會再度驗證，但是當我們修改資料時，可能已經通過驗證了，在等到離開欄位後再認證顯得不夠即時，這也就是常見錯誤2。\n解法：修改錯誤資料時，使用「Validate during the data entry」，每輸入一個字元就驗證一次，一發現通過驗證就馬上隱藏錯誤訊息，如此一來就能達到良好的驗證效果。\n例外： 某些狀況下，可以在資料尚未輸入完之前就驗證並給予警吿\n 在數字欄位中輸入英文字母 在複雜的驗證機制輸入不該出現的字元，像是不符合規範的信用卡號 太長的輸入（例如15位電話號碼）  良好範例  https://ant.design/components/form/?#components-form-demo-register  參考資料\n Usability Testing of Inline Form Validation: 40% Don’t Have It, 20% Get It Wrong Why Users Make More Errors with Instant Inline Validation - After Submit Validation Inline validation is problematic - After Submit Validation Inline Validation in Web Forms Is Inline Validation Worth It? Form validation best practices How to Get Form Validation Right   以下是留著之後消化的資料，但應該會消化不良  利用心理學與科學，完美克服介面上“內容加載”的等待感 對話框的學問－探討按鈕上的用字方法 https://designtongue.me/ux-design-for-internationalization/ 使用 Skeleton Screen 提升用户感知體驗 這個控件叫什麼？ - 逐一介紹popover, tooltip等元件 選取控件的使用時機與限制 Nick Babich寫的ＵＸ文章 利用十大經驗法則與八大黃金律做好基礎易用性檢測—UX Notes 八個互動介面設計的黃金法則 UX-moment: Buttons How to Create Good Error Messages pinkoi redesign 獵人用的 icon 分類法 為使用者設計一個體貼的註冊登入頁 透過量化研究提升 500% 的註冊表現 14 Steps to Building Sign-up Forms That Convert Toast的濫用，可以用其他方代替解決 關於Table Designing Tables for Reusability Designing Settings - 設定頁面製作指南 Design Better Forms - 蠻不錯的文章 Form fields — Required vs Optional - 不要用＊ 使用optional Best layout for a settings page 複雜應用程式的表格設計 Designing UX: Forms Designing More Efficient Forms: Structure, Inputs, Labels And Actions - 表單 all in one The Nine States of Design  ","date":"2019-04-11T14:26:00+08:00","permalink":"https://chiakilalala.github.io/p/ui/ux/","title":"UI/UX 設計指南分享"},{"content":"Whack A Mole Game JS 30day  步驟\nfunction randomTime(min, max) { return Math.round(Math.random() * (max - min) + min); } //隨機老鼠上洞的時間 2 隨機決定哪個洞有老鼠跳來跳去\nfunction randomHole(holes) { const idx = Math.floor(Math.random() * holes.length); //亂數洞 const hole = holes[idx]; if (hole === lastHole) { console.log(\u0026quot;Ah that is the same one bud\u0026quot;); return randomHole(holes); } lastHole = hole; return hole; }  3.因為要避免亂數洞裏同時出現老鼠兩次\nif (hole === lastHole) { console.log(\u0026quot;Ah that is the same one bud\u0026quot;); return randomHole(holes); } lastHole = hole;  4.設定時間到了 就要移除讓老鼠從洞跳到上面的動作\nfunction peep() { const time = randomTime(200, 1000); const hole = randomHole(holes); hole.classList.add('up'); setTimeout(() =\u0026gt; { hole.classList.remove('up'); if(!timeUp) peep(); }, time); }  5.做一個開始按鈕\n\u0026lt;button onClick=\u0026quot;startGame()\u0026quot;\u0026gt;START\u0026lt;/button\u0026gt; function startGame() { scoreBoard.textContent = 0; timeUp = false; // in case page reload score = 0; peep(); setTimeout(() =\u0026gt; timeUp = true, 10000); } //定義遊戲時間動作是10sec 設定時間 timeUp = true  The bonk(e) function function bonk(e) { if(!e.isTrusted) return; // cheater score ++; this.classList.remove('up'); scoreBoard.textContent = score; } moles.forEach(mole =\u0026gt; mole.addEventListener('click', bonk)); //e.isTrusted 這個特性是當我們沒點到洞產生的js屬性 他是點擊產生的\n javascript Math.round() 四捨五入 Math.random() 隨機產生0與1 不包含之間的數值 Math.floor() 向下取整數 或小於 等於指定數值的整數 Math.ceil() 向上取整數 或大於 等於指定數值的整數 亂數介紹 setTimeout() 本身可以在執行功能時工作\n","date":"2019-04-10T14:26:00+08:00","permalink":"https://chiakilalala.github.io/p/javascript/","title":"Whack A Mole Game JS 30day"}]